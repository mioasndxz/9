<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AR ì •ë¦¬ ë„ìš°ë¯¸ (YOLOv8)</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --padding-base: 16px;
            --button-height: 48px;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            margin: 0;
            padding: 0;
            background: #f0f2f5;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
            -webkit-text-size-adjust: 100%;
            font-size: 16px;
        }

        .screen {
            display: none;
            width: 100%;
            max-width: 640px;
            margin: 0 auto;
            box-sizing: border-box;
            padding: 0 var(--padding-base);
            flex-grow: 1;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .screen.active {
            display: flex;
        }

        #loadingScreen, #cameraScreen {
            padding-top: 50px;
        }

        #loadingScreen p {
            font-size: 1.2em;
            font-weight: bold;
            color: #00796b;
            text-align: center;
        }

        #video-container {
            position: relative;
            width: 100%;
            padding-top: 75%;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            margin-bottom: 20px;
        }
        #video, #liveCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #liveCanvas {
            z-index: 10;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            width: 100%;
            gap: 10px;
            margin-top: 10px;
        }
        button {
            padding: 14px 20px;
            font-size: 1.1em;
            font-weight: 700;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s ease;
            width: 100%;
            box-sizing: border-box;
        }
        button:hover {
            background: #357ABD;
            transform: translateY(-2px);
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            z-index: 100;
            justify-content: center;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
        }
        .modal-content {
            background: #fff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
            width: 95%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative;
        }
        .modal-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.8em;
            cursor: pointer;
            color: #888;
            padding: 5px;
        }
        .modal-close-btn:hover {
            color: #555;
        }

        h3 {
            color: #2c3e50;
            margin-top: 0;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
            font-size: 1.2em;
        }
        ul {
            list-style: none;
            padding-left: 0;
            margin: 0;
        }
        li {
            margin: 8px 0;
            display: flex;
            align-items: flex-start;
            font-size: 0.95em;
            line-height: 1.4;
        }
        input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.4);
            accent-color: #4a90e2;
            flex-shrink: 0;
            margin-top: 2px;
        }
        .message-box {
            text-align: center;
            font-weight: bold;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        .error { 
            color: #d32f2f; 
            font-weight: bold; 
            text-align: center; 
            margin-top: 15px; 
            padding: 10px; 
            background-color: #ffebee; 
            border-radius: 8px; 
            font-size: 0.9em;
        }
        .scoreBox, .tipsBox, .spaceBox {
            font-weight: bold;
            color: #2c3e50;
            font-size: 1.1em;
            line-height: 1.5;
            background: #f8f8f8;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        .scoreBox { color: #28a745; font-size: 1.3em; background: #e6ffe6; }
        .tipsBox { color: #007bff; background: #e8f5ff; }
        .spaceBox { color: #6f42c1; background: #f3e6ff; }

        .modal-img-container {
            width: 100%;
            position: relative;
            padding-top: 75%;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 15px;
        }
        #modalCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        @media (max-width: 600px) {
            body {
                font-size: 15px;
            }
            .screen {
                padding: 0 10px;
            }
            button {
                padding: 12px 15px;
                font-size: 1em;
            }
            .modal-content {
                padding: 15px;
            }
            h3 {
                font-size: 1.1em;
            }
            li {
                font-size: 0.9em;
            }
            input[type="checkbox"] {
                transform: scale(1.2);
                margin-top: 1px;
            }
            .scoreBox, .tipsBox, .spaceBox {
                font-size: 1em;
                padding: 10px;
            }
            .error {
                font-size: 0.85em;
            }
        }
    </style>
</head>

<body>

<div id="loadingScreen" class="screen active">
    <p>ëª¨ë¸ ë¡œë”© ì¤‘... ì ì‹œë§Œ ê¸°ë‹¤ë ¤ ì£¼ì„¸ìš”.</p>
</div>

<div id="cameraScreen" class="screen">
    <div id="video-container">
        <video id="video" autoplay muted playsinline crossorigin="anonymous"></video>
        <canvas id="liveCanvas" width="640" height="480"></canvas>
    </div>

    <div class="button-group">
        <button id="analyzeBeforeBtn">ğŸ“¸ í˜„ì¬ ê³µê°„ ë¶„ì„</button>
        <button id="analyzeAfterBtn" disabled>âœ… ì •ë¦¬ í›„ ì ìˆ˜ ë§¤ê¸°ê¸°</button>
    </div>

    <p class="error" id="errorMessage"></p>
    <p id="analysisStatusMessage" style="text-align: center; color: #555; margin-top: 10px;"></p>
</div>

<div id="resultModalOverlay" class="modal-overlay">
    <div class="modal-content">
        <button class="modal-close-btn" onclick="closeResultModal()">&times;</button>
        <h3 id="modalTitle"></h3>
        <div class="modal-img-container">
            <canvas id="modalCanvas" width="640" height="480"></canvas>
        </div>
        <div class="spaceBox" id="modalSpaceInfo"></div>
        <div class="tipsBox" id="modalTipsInfo"></div>
        <div class="scoreBox" id="modalScoreInfo"></div>
        <div id="modalChecklistInfo"></div>
        <p id="modalFeedbackMessage"></p>
        <button onclick="closeResultModal()">í™•ì¸</button>
        <button id="resetAppBtn" style="background: #dc3545; display: none;" onclick="resetApplication()">ë‹¤ì‹œ ì‹œì‘</button>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0"></script>
<script>
    const loadingScreen = document.getElementById("loadingScreen");
    const cameraScreen = document.getElementById("cameraScreen");
    const video = document.getElementById("video");
    const liveCanvas = document.getElementById("liveCanvas");
    const liveCtx = liveCanvas.getContext("2d");
    const analyzeBeforeBtn = document.getElementById("analyzeBeforeBtn");
    const analyzeAfterBtn = document.getElementById("analyzeAfterBtn");
    const errorMessage = document.getElementById("errorMessage");
    const analysisStatusMessage = document.getElementById("analysisStatusMessage");

    const resultModalOverlay = document.getElementById("resultModalOverlay");
    const modalTitle = document.getElementById("modalTitle");
    const modalCanvas = document.getElementById("modalCanvas");
    const modalCtx = modalCanvas.getContext("2d");
    const modalSpaceInfo = document.getElementById("modalSpaceInfo");
    const modalTipsInfo = document.getElementById("modalTipsInfo");
    const modalScoreInfo = document.getElementById("modalScoreInfo");
    const modalChecklistInfo = document.getElementById("modalChecklistInfo");
    const modalFeedbackMessage = document.getElementById("modalFeedbackMessage");
    const resetAppBtn = document.getElementById("resetAppBtn");

    let yoloModel = null; // YOLOv8 ëª¨ë¸ ë³€ìˆ˜ëª… ë³€ê²½ (clutterModel -> yoloModel)
    let customLabels = []; // label.txtì—ì„œ ë¡œë“œí•  ì»¤ìŠ¤í…€ ë ˆì´ë¸”
    let beforeLabels = [];
    let beforeSnapshotData = null; 
    
    // YOLOv8 ëª¨ë¸ì˜ ì…ë ¥ í¬ê¸° (ëª¨ë¸ í•™ìŠµ ì‹œ ì‚¬ìš©í•œ ì´ë¯¸ì§€ í¬ê¸°ì™€ ì¼ì¹˜í•´ì•¼ í•¨)
    // yolov8n_oiv7_web_modelì€ 640x640ì„ ê¸°ë³¸ìœ¼ë¡œ ê°€ì •í•©ë‹ˆë‹¤.
    const MODEL_INPUT_SIZE = 640; 
    const IOU_THRESHOLD = 0.45; // Intersection Over Union ì„ê³„ê°’ (NMSìš©)
    const CONF_THRESHOLD = 0.25; // Confidence Score ì„ê³„ê°’ (ê°ì²´ í•„í„°ë§ìš©)

    // Open Images V7 ë ˆì´ë¸” ì¤‘ ë°©ì—ì„œ 'ì–´ì§€ëŸ½í˜'ìœ¼ë¡œ ê°„ì£¼ë  ìˆ˜ ìˆëŠ” ê°ì²´ë“¤ì˜ ëª©ë¡ (ìµœì¢… ì—…ë°ì´íŠ¸ë¨)
    const hardcodedMessyLabels = [
        // ì˜ë¥˜ ë° ê°œì¸ ìš©í’ˆ
        'Backpack', 'Bag', 'Briefcase', 'Clothing', 'Coat', 'Dress', 'Footwear', 'Glove', 'Handbag', 'Hat', 'Helmet',
        'High heels', 'Jacket', 'Jeans', 'Luggage and bags', 'Miniskirt', 'Pants', 'Sandal', 'Scarf', 'Shirt', 'Shoes',
        'Shorts', 'Sock', 'Suit', 'Suitcase', 'Swimwear', 'Tie', 'Trousers', 'Watch',
        'Glasses', 'Sunglasses', 'Earrings', 'Necklace', 'Ring', 'Crown', 'Tiara', 'Fashion accessory',
        'Cosmetics', 'Face powder', 'Hair dryer', 'Hair spray', 'Lipstick', 'Perfume', 'Toothbrush', 'Personal care',

        // ì±… ë° ì‚¬ë¬´ìš©í’ˆ
        'Book', 'Bookcase', 'Paper', 'Magazine', 'Pen', 'Pencil case', 'Pencil sharpener', 'Eraser', 'Ring binder',
        'Office supplies', 'Ruler', 'Stapler', 'Whiteboard', 'Printer', 'Fax',

        // ìŒì‹ ë° ì£¼ë°© ìš©í’ˆ (ë°©ì— ìˆì„ ê²½ìš° ì–´ì§€ëŸ¬ì›€)
        'Apple', 'Banana', 'Bread', 'Cabbage', 'Carrot', 'Cheese', 'Common fig', 'Cucumber', 'Egg (Food)', 'Fruit',
        'Garden Asparagus', 'Grape', 'Grapefruit', 'Lemon', 'Mango', 'Mushroom', 'Orange', 'Pancake', 'Peach', 'Pear',
        'Pineapple', 'Pizza', 'Potato', 'Pumpkin', 'Radish', 'Salad', 'Sandwich', 'Snack', 'Strawberry', 'Sushi', 'Taco',
        'Tart', 'Tomato', 'Vegetable', 'Watermelon', 'Winter melon', 'Zucchini',
        'Beer', 'Coffee', 'Cocktail', 'Drink', 'Juice', 'Milk', 'Tea', 'Wine',
        'Bagel', 'Baked goods', 'Candy', 'Cookie', 'Croissant', 'Dessert', 'Doughnut', 'Hamburger', 'Hot dog', 'Ice cream',
        'Muffin', 'Popcorn', 'Pretzel', 'Submarine sandwich', 'Waffle',
        'Bottle', 'Bottle opener', 'Bowl', 'Can opener', 'Coffee cup', 'Container', 'Cooking spray', 'Cup', 'Drinking straw',
        'Frying pan', 'Jug', 'Kettle', 'Kitchen knife', 'Kitchen utensil', 'Kitchenware', 'Ladle', 'Measuring cup',
        'Mixing bowl', 'Mug', 'Plate', 'Platter', 'Saucer', 'Serving tray', 'Spice rack', 'Spoon', 'Teapot', 'Tin can',
        'Tableware', 'Whisk', 'Wine glass', 'Wok',

        // ê°€êµ¬ ë° ì†Œí’ˆ (ë°©ì¹˜ë  ê²½ìš° ì–´ì§€ëŸ¬ì›€)
        'Chair', 'Couch', 'Bed', 'Desk', 'Nightstand', 'Table', 'Coffee table', 'Kitchen & dining room table', 'Stool',
        'Studio couch', 'Sofa bed', 'Cabinetry', 'Chest of drawers', 'Closet', 'Cupboard', 'Drawer', 'Filing cabinet',
        'Shelf', 'Wardrobe', 'Television', 'Computer keyboard', 'Computer monitor', 'Computer mouse', 'Laptop',
        'Mobile phone', 'Remote control', 'Tablet computer', 'Telephone', 'Ipod', 'Headphones', 'Speaker',
        'Alarm clock', 'Clock', 'Digital clock', 'Wall clock',
        'Lamp', 'Light bulb', 'Flowerpot', 'Houseplant', 'Vase', 'Picture frame', 'Poster', 'Mirror',
        'Pillow', 'Towel', 'Blanket', 'Curtain', 'Window blind',
        'Box', 'Plastic bag', 'Waste container', 

        // ì¥ë‚œê° ë° ìŠ¤í¬ì¸  ìš©í’ˆ
        'Ball', 'Balloon', 'Doll', 'Flying disc', 'Toy', 'Teddy bear',
        'Baseball bat', 'Baseball glove', 'Billiard table', 'Bowling equipment', 'Cricket ball', 'Dumbbell', 'Football',
        'Football helmet', 'Golf ball', 'Golf cart', 'Racket', 'Rugby ball', 'Skateboard', 'Ski', 'Snowboard',
        'Sports equipment', 'Table tennis racket', 'Tennis ball', 'Tennis racket', 'Unicycle', 'Volleyball (Ball)',

        // ê¸°íƒ€ (ë°©ì— ìˆì„ ë²•í•œ ì¡ë™ì‚¬ë‹ˆ)
        'Accordion', 'Axe', 'Band-aid', 'Banjo', 'Barrel', 'Bell pepper', 'Binoculars', 'Blender', 'Bomb', 'Cello', 'Chime',
        'Chisel', 'Chopsticks', 'Coffeemaker', 'Coin', 'Corded phone', 'Crutch', 'Cutting board', 'Dagger', 'Dice',
        'Dishwasher', 'Door handle', 'Drill (Tool)', 'Drum', 'Fountain', 'Gas stove', 'Grinder', 'Guacamole', 'Guitar',
        'Hammer', 'Harmonica', 'Harp', 'Harpsichord', 'Heater', 'Honeycomb', 'Humidifier', 'Jacuzzi', 'Jet ski', 'Kite',
        'Knife', 'Ladder', 'Lantern', 'Light switch', 'Maracas', 'Mechanical fan', 'Medical equipment', 'Microphone',
        'Microwave oven', 'Mixer', 'Musical instrument', 'Musical keyboard', 'Nail (Construction)', 'Oboe', 'Office building',
        'Organ (Musical Instrument)', 'Oven', 'Paddle', 'Paper cutter', 'Paper towel', 'Pianoforte', 'Picnic basket',
        'Pliers', 'Plumbing fixture', 'Power plugs and sockets', 'Pressure cooker', 'Punching bag', 'Ratchet (Device)',
        'Refrigerator', 'Scissors', 'Screwdriver', 'Sewing machine', 'Shower', 'Sink', 'Slow cooker', 'Soap dispenser',
        'Spatula', 'Stethoscope', 'Stop sign', 'Syringe', 'Tank', 'Tap', 'Tool', 'Torch', 'Traffic light', 'Traffic sign',
        'Training bench', 'Treadmill', 'Tripod', 'Trombone', 'Trumpet', 'Umbrella', 'Waffle iron', 'Wheelchair', 'Wrench',
        'Wagon', 'Walkie-talkie', 'Water bottle', 'Water heater', 'Water cooler', 'Welding mask', 'Washing machine',
        'Vacuum cleaner', 'Steam iron'
    ];
    
    // ì ìˆ˜ ê³„ì‚°ì— ì‹¤ì œë¡œ ì‚¬ìš©ë  'ì–´ì§€ëŸ½í˜' ê°ì²´ ëª©ë¡ (hardcodedMessyLabelsì™€ customLabelsì˜ êµì§‘í•©)
    let messyLabelsForScoring = [];

    // label.txt íŒŒì¼ì„ ë¡œë“œí•˜ëŠ” í•¨ìˆ˜
    async function loadLabels(path) {
        try {
            const response = await fetch(path);
            const text = await response.text();
            // 'names:' ì´í›„ì˜ ë¼ì¸ë“¤ì„ íŒŒì‹±
            const lines = text.split('\n');
            const startIndex = lines.findIndex(line => line.includes('names:')) + 1;
            const labels = [];
            for (let i = startIndex; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line) {
                    const match = line.match(/^\s*\d+:\s*(.*)/); // "570: Trombone" í˜•ì‹ íŒŒì‹± (ì‹œì‘ ê³µë°±ë„ ê³ ë ¤)
                    if (match && match[1]) {
                        labels.push(match[1].trim());
                    }
                }
            }
            return labels;
        } catch (error) {
            console.error("Error loading labels:", error);
            errorMessage.textContent = "â— ë ˆì´ë¸” íŒŒì¼ì„ ë¡œë“œí•˜ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: " + error.message;
            return [];
        }
    }

    // ì»¤ìŠ¤í…€ ë ˆì´ë¸”ì„ ì‚¬ìš©ì ì¹œí™”ì ì¸ ì´ë¦„ìœ¼ë¡œ ë§¤í•‘í•˜ê³ , íŠ¹ì • ê°ì²´ ê·¸ë£¹í™”
    // ì´ í•¨ìˆ˜ëŠ” ì´ì œ customLabels (yolov8n_oiv7_web_modelì˜ ë ˆì´ë¸”)ì„ ê¸°ë°˜ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤.
    function mapLabelToFriendlyName(label) {
        if(!label) return '';
        // Open Images V7 ë ˆì´ë¸”ì€ ì´ë¯¸ ì‚¬ìš©ì ì¹œí™”ì ì´ë¯€ë¡œ ê·¸ëŒ€ë¡œ ë°˜í™˜
        return label; 
    }

    // íŒ ì‚¬ì „ (YOLOv8 ëª¨ë¸ì˜ ì»¤ìŠ¤í…€ ë ˆì´ë¸”ì— ë§ì¶° ì—…ë°ì´íŠ¸ í•„ìš”)
    const tipDictionary = {
        'Book': "ğŸ“š ì±…ì€ ì±…ê½‚ì´ë‚˜ ì„ ë°˜ì— ì •ë¦¬í•´ ì£¼ì„¸ìš”.",
        'Cup': "â˜• ì»µì€ ì”»ì–´ì„œ ê±´ì¡°ëŒ€ì— ë†“ê±°ë‚˜ ìˆ˜ë‚©í•˜ì„¸ìš”.",
        'Bottle': "ğŸ§´ ë³‘ì€ ë‚´ìš©ë¬¼ì„ ë¹„ìš°ê³  ë¶„ë¦¬ìˆ˜ê±°í•˜ê±°ë‚˜ ì œìë¦¬ì— ë³´ê´€í•˜ì„¸ìš”.",
        'Laptop': "ğŸ’» ë…¸íŠ¸ë¶ì€ ì‚¬ìš© í›„ ë‹«ì•„ì„œ ì •í•´ì§„ ìœ„ì¹˜ì— ë†“ìœ¼ì„¸ìš”.",
        'Chair': "ğŸª‘ ì˜ìëŠ” ì‚¬ìš© í›„ ì±…ìƒ ì•„ë˜ë¡œ ë°€ì–´ ë„£ì–´ì£¼ì„¸ìš”.",
        'Backpack': "ğŸ’ ê°€ë°©ì€ ë‚´ìš©ë¬¼ì„ ë¹„ìš°ê³  ì œìë¦¬ì— ê±¸ì–´ë‘ì„¸ìš”.",
        'Mobile phone': "ğŸ“± íœ´ëŒ€í°ì€ ì¶©ì „ ìœ„ì¹˜ë‚˜ ì „ìš© ê±°ì¹˜ëŒ€ì— ë³´ê´€í•˜ì„¸ìš”.",
        'Remote control': "ğŸ•¹ï¸ ë¦¬ëª¨ì»¨ì€ ì œìë¦¬ì— ë‘ê±°ë‚˜ ìˆ˜ë‚©í•¨ì— ë„£ì–´ì£¼ì„¸ìš”.",
        'Computer keyboard': "âŒ¨ï¸ ì‚¬ìš© í›„ì—ëŠ” ì œ ìœ„ì¹˜ì— ë‘ê±°ë‚˜ ì •ë¦¬í•˜ì„¸ìš”.",
        'Mouse': "ğŸ–±ï¸ ì‚¬ìš© í›„ì—ëŠ” ì œ ìœ„ì¹˜ì— ë‘ê±°ë‚˜ ì •ë¦¬í•˜ì„¸ìš”.",
        'Toothbrush': "ğŸª¥ ì¹«ì†”ì€ ì‚¬ìš© í›„ ì¹«ì†”ê½‚ì´ì— ì œëŒ€ë¡œ ë³´ê´€í•˜ì„¸ìš”.",
        'Clothing': "ğŸ‘• ì˜·ì€ ì˜·ì¥ì´ë‚˜ ì„¸íƒ ë°”êµ¬ë‹ˆì— ë„£ì–´ì£¼ì„¸ìš”.",
        'Shoes': "ğŸ‘Ÿ ì‹ ë°œì€ ì‹ ë°œì¥ì— ì •ë¦¬í•´ ì£¼ì„¸ìš”.",
        'Dishes': "ğŸ½ï¸ ì ‘ì‹œì™€ ê·¸ë¦‡ì€ ì„¤ê±°ì§€ í›„ ì œìë¦¬ì— ìˆ˜ë‚©í•˜ì„¸ìš”.",
        'Paper': "ğŸ“„ ì¢…ì´ëŠ” ë¶„ë¥˜í•˜ì—¬ ì¬í™œìš©í•˜ê±°ë‚˜ íŒŒì¼ì— ë³´ê´€í•˜ì„¸ìš”.",
        'Cosmetics': "ğŸ’„ í™”ì¥í’ˆì€ í™”ì¥ëŒ€ì— ì •ëˆí•˜ê±°ë‚˜ ì„œëì— ë³´ê´€í•˜ì„¸ìš”.",
        'Toy': "ğŸ§¸ ì¥ë‚œê°ì€ ë†€ì´ í›„ ì¥ë‚œê° ìƒìì— ì •ë¦¬í•˜ì„¸ìš”.",
        'Waste container': "ğŸ—‘ï¸ ì“°ë ˆê¸°í†µì´ ê°€ë“ ì°¼ë‹¤ë©´ ë¹„ì›Œì£¼ì„¸ìš”.",
        'Pillow': "ğŸ›Œ ë² ê°œëŠ” ì¹¨ëŒ€ ìœ„ì— ê°€ì§€ëŸ°íˆ ë†“ìœ¼ì„¸ìš”.",
        'Towel': "ğŸ›€ ìˆ˜ê±´ì€ ì‚¬ìš© í›„ ë¹¨ë˜í†µì— ë„£ê±°ë‚˜ ê±´ì¡°ëŒ€ì— ë„ì–´ì£¼ì„¸ìš”.",
        'Bag': "ğŸ‘œ ê°€ë°©ì€ ë‚´ìš©ë¬¼ì„ ë¹„ìš°ê³  ì •í•´ì§„ ê³³ì— ë‘ì„¸ìš”.",
        'Food': "ğŸ ìŒì‹ë¬¼ ì“°ë ˆê¸°ëŠ” ì œë•Œ ë²„ë¦¬ê³ , ë‚¨ì€ ìŒì‹ì€ ëƒ‰ì¥ê³ ì— ë³´ê´€í•˜ì„¸ìš”."
        // ì¶”ê°€: ë‹¤ë¥¸ ë ˆì´ë¸”ì— ëŒ€í•œ íŒì„ ì—¬ê¸°ì— ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    };

    // ì²´í¬ë¦¬ìŠ¤íŠ¸ ì‚¬ì „ (YOLOv8 ëª¨ë¸ì˜ ì»¤ìŠ¤í…€ ë ˆì´ë¸”ì— ë§ì¶° ì—…ë°ì´íŠ¸ í•„ìš”)
    const checklistDictionary = {
        'Book': ["ì±…ê½‚ì´ì— ë„£ê¸°", "ì½ì§€ ì•ŠëŠ” ì±… ë¶„ë¥˜"],
        'Cup': ["ì»µ ì”»ê¸°", "ê±´ì¡°ëŒ€ì— ë†“ê¸°", "ìˆ˜ë‚©í•˜ê¸°"],
        'Bottle': ["ëšœê»‘ ë‹«ê¸°", "ì¬í™œìš©í•¨ì— ë„£ê¸°", "ë‚´ìš©ë¬¼ ë¹„ìš°ê¸°"],
        'Laptop': ["ë®ê°œ ë‹«ê¸°", "ì¶©ì „ê¸° ì •ë¦¬", "ì „ì› ë„ê¸°"],
        'Chair': ["ì •ìœ„ì¹˜ ì •ë ¬", "ì˜ì ìœ„ ë¬¼ê±´ ì •ë¦¬"],
        'Backpack': ["ë‚´ìš©ë¬¼ ë¹„ìš°ê¸°", "ì œìë¦¬ì— ê±¸ê¸°/ë‘ê¸°"],
        'Mobile phone': ["ì¶©ì „ ìœ„ì¹˜ì— ë‘ê¸°", "ê±°ì¹˜ëŒ€ì— ë†“ê¸°"],
        'Remote control': ["ì œìë¦¬ë¡œ ì˜®ê¸°ê¸°"],
        'Computer keyboard': ["ì •ë¦¬ í›„ ì œìë¦¬ì— ë†“ê¸°"],
        'Mouse': ["ì •ë¦¬ í›„ ì œìë¦¬ì— ë†“ê¸°"],
        'Toothbrush': ["ì¹«ì†”ê½‚ì´ì— ë³´ê´€í•˜ê¸°"],
        'Clothing': ["ì˜·ì¥/ì„œëì— ë„£ê¸°", "ì„¸íƒ ë°”êµ¬ë‹ˆì— ë„£ê¸°"],
        'Shoes': ["ì‹ ë°œì¥ì— ë„£ê¸°", "í™ í„¸ê¸°"],
        'Dishes': ["ì„¤ê±°ì§€ í•˜ê¸°", "ê±´ì¡°/ìˆ˜ë‚©í•˜ê¸°"],
        'Paper': ["ë¶„ë¥˜í•˜ì—¬ ì¬í™œìš©", "ì„œë¥˜ì² ì— ì •ë¦¬"],
        'Cosmetics': ["í™”ì¥ëŒ€ì— ì •ëˆí•˜ê¸°", "ì„œëì— ë³´ê´€"],
        'Toy': ["ì¥ë‚œê° ìƒìì— ë„£ê¸°", "ì¢…ë¥˜ë³„ë¡œ ë¶„ë¥˜"],
        'Waste container': ["ì“°ë ˆê¸° ë¹„ìš°ê¸°", "ì“°ë ˆê¸°í†µ ë‹¦ê¸°"],
        'Pillow': ["ì¹¨ëŒ€ ì •ë¦¬í•˜ê¸°", "ë² ê°œ ì»¤ë²„ êµì²´"],
        'Towel': ["ë¹¨ë˜í†µì— ë„£ê¸°", "ê±´ì¡°ëŒ€ì— ë„ê¸°"],
        'Bag': ["ë‚´ìš©ë¬¼ ë¹„ìš°ê¸°", "ì •í•´ì§„ ê³³ì— ë‘ê¸°"],
        'Food': ["ë‚¨ì€ ìŒì‹ ëƒ‰ì¥ê³ ì— ë„£ê¸°", "ìœ í†µê¸°í•œ í™•ì¸"]
        // ì¶”ê°€: ë‹¤ë¥¸ ë ˆì´ë¸”ì— ëŒ€í•œ ì²´í¬ë¦¬ìŠ¤íŠ¸ë¥¼ ì—¬ê¸°ì— ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    };

    // ê³µê°„ ì¶”ë¡ ì„ ìœ„í•œ í‚¤ì›Œë“œ ê·¸ë£¹ (YOLOv8 ëª¨ë¸ì˜ ë ˆì´ë¸” ê¸°ì¤€ìœ¼ë¡œ í™•ì¥ í•„ìš”)
    const spaceGroups = {
        'ì±…ìƒ ì£¼ë³€': ["Book", "Laptop", "Mouse", "Computer keyboard", "Cup", "Chair", "Pen", "Paper"],
        'ì¹¨ì‹¤': ["Bed", "Pillow", "Blanket", "Book", "Clothing", "Nightstand"], 
        'ì£¼ë°©': ["Cup", "Bottle", "Bowl", "Refrigerator", "Microwave oven", "Plate", "Fork", "Knife", "Spoon", "Oven"], 
        'ê±°ì‹¤': ["Couch", "Television", "Potted plant", "Chair", "Remote control", "Bookcase", "Coffee table", "Vase", "Picture frame"], 
        'ìš•ì‹¤': ["Toilet", "Toothbrush", "Cosmetics", "Mirror", "Towel", "Shower", "Soap dispenser"],
        'í˜„ê´€/ë³µë„': ["Shoes", "Backpack", "Bag", "Coat", "Hat", "Umbrella"]
        // TODO: ì»¤ìŠ¤í…€ ëª¨ë¸ì´ ê°ì§€í•˜ëŠ” ê°ì²´ë¥¼ í™œìš©í•˜ì—¬ ê³µê°„ ê·¸ë£¹ì„ í™•ì¥í•˜ì„¸ìš”.
    };

    // í˜„ì¬ í™œì„±í™”ëœ í™”ë©´ì„ ë³€ê²½í•˜ëŠ” í•¨ìˆ˜
    function showScreen(screenId) {
        document.querySelectorAll('.screen').forEach(screen => {
            screen.classList.remove('active');
        });
        document.getElementById(screenId).classList.add('active');
    }

    // ëª¨ë‹¬ ì—´ê¸°/ë‹«ê¸°
    function openResultModal(title, spaceInfo, tipsInfo, scoreInfo, checklistInfo, feedbackMessage, showResetBtn = false) {
        modalTitle.textContent = title;
        modalSpaceInfo.innerHTML = `<h3>ğŸ  ì˜ˆìƒ ê³µê°„</h3><p>${spaceInfo}</p>`;
        modalTipsInfo.innerHTML = `<h3>ğŸ’¡ ì •ë¦¬ íŒ</h3><p>${tipsInfo}</p>`;
        modalScoreInfo.innerHTML = scoreInfo ? `<h3>âœ¨ ì •ë¦¬ ì ìˆ˜</h3><p>${scoreInfo}</p>` : '';
        modalChecklistInfo.innerHTML = checklistInfo ? `<h3>âœ”ï¸ ì •ë¦¬ ì²´í¬ë¦¬ìŠ¤íŠ¸</h3>${checklistInfo}` : '';
        modalFeedbackMessage.textContent = feedbackMessage;
        resetAppBtn.style.display = showResetBtn ? 'block' : 'none'; // ë‹¤ì‹œ ì‹œì‘ ë²„íŠ¼ í‘œì‹œ ì—¬ë¶€

        resultModalOverlay.style.display = 'flex'; // flexë¡œ ë³€ê²½í•˜ì—¬ ê°€ìš´ë° ì •ë ¬ ìœ ì§€
    }

    function closeResultModal() {
        resultModalOverlay.style.display = 'none';
    }

    // ì–´ë–¤ ê³µê°„ì¸ì§€ ì¶”ë¡  (ê°€ì¥ ë§ì´ ê°ì§€ëœ ê°ì²´ê°€ ì†í•œ ê·¸ë£¹ìœ¼ë¡œ íŒë‹¨)
    function guessSpace(labels) {
        const counts = {};
        // labelì€ Open Images V7ì˜ ì›ë³¸ ì´ë¦„ (ì˜ˆ: "Book")
        for (const key in spaceGroups) {
            counts[key] = labels.filter(l => spaceGroups[key].includes(l)).length;
        }
        const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
        if (sorted.length > 0 && sorted[0][1] > 0) { // ìµœì†Œ 1ê°œ ì´ìƒ ê°ì§€ë  ë•Œ ìœ íš¨
            return sorted[0][0];
        }
        return "ì•Œ ìˆ˜ ì—†ëŠ” ê³µê°„";
    }

    function generateTips(labels) {
        // labelsëŠ” ëª¨ë¸ì´ ê°ì§€í•œ ì›ë³¸ ë ˆì´ë¸” (ì˜ˆ: "Book")
        const uniqueLabels = [...new Set(labels)];
        const tips = uniqueLabels.map(l => tipDictionary[l]).filter(Boolean);
        return tips.length ? tips.join(" ") : "ğŸ‘ í˜„ì¬ íŠ¹ë³„íˆ ì •ë¦¬í•  ë¬¼ê±´ì´ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!";
    }

    function calculateScore(before, after) {
        let score = 50; // ê¸°ë³¸ ì ìˆ˜
        let feedback = "";

        const beforeSet = new Set(before.map(l => l.toLowerCase())); // ë¹„êµë¥¼ ìœ„í•´ ì†Œë¬¸ìë¡œ ë³€í™˜
        const afterCounts = {};
        after.map(l => l.toLowerCase()).forEach(item => { afterCounts[item] = (afterCounts[item] || 0) + 1; }); // ì†Œë¬¸ìë¡œ ë³€í™˜í•˜ì—¬ ì¹´ìš´íŠ¸

        let removedCount = 0;
        let addedCount = 0;
        let improvedMessyScore = 0;

        const beforeCounts = {};
        before.map(l => l.toLowerCase()).forEach(item => { beforeCounts[item] = (beforeCounts[item] || 0) + 1; }); // ì†Œë¬¸ìë¡œ ë³€í™˜í•˜ì—¬ ì¹´ìš´íŠ¸

        // ì‚¬ë¼ì§„ ê°ì²´ ë° ê°ì†Œí•œ ì–´ì§€ëŸ½í˜ ê°ì²´ í™•ì¸
        beforeSet.forEach(item => { // itemì€ ì´ë¯¸ ì†Œë¬¸ì
            const beforeQty = beforeCounts[item] || 0;
            const afterQty = afterCounts[item] || 0;

            if (beforeQty > afterQty) {
                removedCount += (beforeQty - afterQty);
                // messyLabelsForScoringë„ ì†Œë¬¸ìë¡œ ì €ì¥ë˜ì–´ ìˆìœ¼ë¯€ë¡œ, itemê³¼ ì§ì ‘ ë¹„êµ
                if (messyLabelsForScoring.includes(item)) { 
                    improvedMessyScore += (beforeQty - afterQty) * 10; // ì–´ì§€ëŸ½í˜ ê°ì²´ ê°ì†Œ ì‹œ ê°€ì¤‘ì¹˜
                }
            }
        });

        // ì¶”ê°€ëœ ê°ì²´ í™•ì¸
        after.map(l => l.toLowerCase()).forEach(item => { // itemì€ ì´ë¯¸ ì†Œë¬¸ì
            const beforeQty = beforeCounts[item] || 0;
            const afterQty = afterCounts[item] || 0;
            if (afterQty > beforeQty) {
                addedCount += (afterQty - beforeQty);
            }
        });

        score += removedCount * 5; // ì‚¬ë¼ì§„ ê°ì²´ë‹¹ ì ìˆ˜
        score += improvedMessyScore; // ì–´ì§€ëŸ½í˜ ê°ì²´ ê°ì†Œë¡œ ì¸í•œ ì¶”ê°€ ì ìˆ˜
        score -= addedCount * 3; // ìƒˆë¡œìš´ ê°ì²´ê°€ ìƒê¸°ë©´ ê°ì  (ìƒˆë¡œìš´ ì“°ë ˆê¸° ë“±)

        if (score > 100) score = 100;
        if (score < 0) score = 0;

        if (score >= 90) feedback = "ì •ë§ ê¹¨ë—í•˜ê²Œ ì •ë¦¬í–ˆì–´ìš”! í›Œë¥­í•©ë‹ˆë‹¤! ğŸ‰";
        else if (score >= 70) feedback = "ì•„ì£¼ ì˜ ì •ë¦¬í–ˆì–´ìš”! ë‹¤ìŒì—” ë” ì™„ë²½í•˜ê²Œ! ğŸ‘";
        else if (score >= 50) feedback = "ê½¤ ê´œì°®ê²Œ ì •ë¦¬í–ˆë„¤ìš”. ì¡°ê¸ˆë§Œ ë” ë…¸ë ¥í•˜ë©´ ì™„ë²½í•´ì ¸ìš”! ğŸ˜‰";
        else feedback = "ì¡°ê¸ˆ ë” ì •ë¦¬í•´ì•¼ í•  ê²ƒ ê°™ì•„ìš”. ë‹¤ìŒ ë²ˆì—ëŠ” ë” ì˜í•  ìˆ˜ ìˆì–´ìš”! ğŸ’ª";

        return { score: `ğŸ§¹ ì •ë¦¬ ì ìˆ˜: ${score}ì  (ì •ë¦¬ ì „ ${before.length}ê°œ â†’ ì •ë¦¬ í›„ ${after.length}ê°œ ê°ì§€)`, feedback: feedback };
    }

    function generateChecklistHtml(labels) {
        let html = `<ul>`; 
        const uniqueLabels = [...new Set(labels)]; // ì›ë³¸ ë ˆì´ë¸” ê·¸ëŒ€ë¡œ ì‚¬ìš©
        let hasTasks = false;

        uniqueLabels.forEach(label => {
            const tasks = checklistDictionary[label];
            if (tasks && tasks.length > 0) {
                hasTasks = true;
                html += `<li><strong>${mapLabelToFriendlyName(label)} ê´€ë ¨:</strong></li>`;
                tasks.forEach(task => {
                    html += `<li><input type="checkbox"> ${task}</li>`;
                });
            }
        });

        if (!hasTasks) {
            html += `<li>í˜„ì¬ ì •ë¦¬í•  í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤.</li>`;
        }
        html += '</ul>';
        return html;
    }

    // ìº”ë²„ìŠ¤ì— ë°”ìš´ë”© ë°•ìŠ¤ ê·¸ë¦¬ê¸°
    function drawBoundingBoxes(targetCtx, targetCanvas, results) {
        targetCtx.clearRect(0, 0, targetCanvas.width, targetCanvas.height); // ì´ì „ ê·¸ë¦¼ ì§€ìš°ê¸°

        results.forEach(prediction => {
            const [x, y, width, height] = prediction.bbox;
            targetCtx.strokeStyle = '#00FF00'; // ì´ˆë¡ìƒ‰ ë°•ìŠ¤
            targetCtx.lineWidth = 3;
            targetCtx.strokeRect(x, y, width, height);

            targetCtx.fillStyle = '#00FF00'; // ì´ˆë¡ìƒ‰ ê¸€ì ë°°ê²½
            targetCtx.font = 'bold 18px Noto Sans KR';
            const friendlyLabel = mapLabelToFriendlyName(prediction.class);
            const text = `${friendlyLabel} (${Math.round(prediction.score * 100)}%)`;
            const textWidth = targetCtx.measureText(text).width;
            
            // í…ìŠ¤íŠ¸ ë°°ê²½ì„ ë°•ìŠ¤ ìœ„ì— ê·¸ë¦¬ë˜, ìº”ë²„ìŠ¤ ìƒë‹¨ì„ ë²—ì–´ë‚˜ì§€ ì•Šë„ë¡ ì¡°ì •
            const textBgY = y - 20;
            const textY = y - 5;

            if (textBgY < 0) { // í…ìŠ¤íŠ¸ê°€ ìº”ë²„ìŠ¤ ìƒë‹¨ì„ ë²—ì–´ë‚˜ëŠ” ê²½ìš°
                targetCtx.fillRect(x, y, textWidth + 8, 20); // ë°•ìŠ¤ ì‹œì‘ì ì— ê·¸ë¦¬ê¸°
                targetCtx.fillStyle = '#000000';
                targetCtx.fillText(text, x + 4, y + 15); // ê¸€ì ìœ„ì¹˜ ì¡°ì •
            } else {
                targetCtx.fillRect(x, textBgY, textWidth + 8, 20);
                targetCtx.fillStyle = '#000000';
                targetCtx.fillText(text, x + 4, textY);
            }
        });
    }


    async function processYoloOutput(output, imgWidth, imgHeight, labels, iouThreshold, confThreshold) {


        let detections = [];
        const data = output.dataSync(); // ëª¨ë¸ ì¶œë ¥ í…ì„œì˜ ë°ì´í„°ë¥¼ ë™ê¸°ì ìœ¼ë¡œ ê°€ì ¸ì˜µë‹ˆë‹¤.

        const boxes = [];
        const scores = [];
        const classes = [];

        const numPredictions = output.shape[1]; // ì˜ˆë¥¼ ë“¤ì–´ 8400 (N)
        const numClasses = output.shape[2] - 4; // ì˜ˆë¥¼ ë“¤ì–´ 600 (Open Images V7 í´ë˜ìŠ¤ ìˆ˜)

        // ëª¨ë¸ ì¶œë ¥ í…ì„œê°€ [1, num_predictions, x_center, y_center, width, height, class_scores...] í˜•íƒœì¼ ë•Œ
        for (let i = 0; i < numPredictions; i++) {
            const offset = i * (4 + numClasses);
            const bbox = [
                data[offset],      // x_center (normalized)
                data[offset + 1],  // y_center (normalized)
                data[offset + 2],  // width (normalized)
                data[offset + 3]   // height (normalized)
            ];

            // í´ë˜ìŠ¤ ì ìˆ˜ ë°°ì—´ì—ì„œ ê°€ì¥ ë†’ì€ ì ìˆ˜ì™€ í•´ë‹¹ í´ë˜ìŠ¤ ì¸ë±ìŠ¤ ì°¾ê¸°
            let maxScore = -1;
            let classId = -1;
            for (let j = 0; j < numClasses; j++) {
                const classScore = data[offset + 4 + j];
                if (classScore > maxScore) {
                    maxScore = classScore;
                    classId = j;
                }
            }

            if (maxScore >= confThreshold) {
                // YOLO ì¶œë ¥ (cx, cy, w, h)ë¥¼ (x1, y1, w, h)ë¡œ ë³€í™˜í•˜ê³ , ì´ë¯¸ì§€ í¬ê¸°ì— ë§ì¶° ìŠ¤ì¼€ì¼ë§
                const x_center = bbox[0] * imgWidth;
                const y_center = bbox[1] * imgHeight;
                const width = bbox[2] * imgWidth;
                const height = bbox[3] * imgHeight;

                const x1 = x_center - width / 2;
                const y1 = y_center - height / 2;

                boxes.push([x1, y1, x1 + width, y1 + height]); // NMSë¥¼ ìœ„í•´ [x1, y1, x2, y2]
                scores.push(maxScore);
                classes.push(classId);
            }
        }
        
        // ë¹„ë™ê¸° NMS ì‹¤í–‰
        const nmsTensor = await tf.image.nonMaxSuppressionAsync(
            tf.tensor2d(boxes),
            tf.tensor1d(scores),
            boxes.length, // maxNumBoxes
            iouThreshold,
            confThreshold
        );

        const nmsIndices = await nmsTensor.array();

        // NMS ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ìµœì¢… ê°ì§€ ê²°ê³¼ ìƒì„±
        for (const i of nmsIndices) {
            const x1 = boxes[i][0];
            const y1 = boxes[i][1];
            const x2 = boxes[i][2];
            const y2 = boxes[i][3];

            detections.push({
                bbox: [x1, y1, x2 - x1, y2 - y1], // [x, y, width, height] í˜•ì‹
                class: labels[classes[i]], // customLabels ë°°ì—´ì—ì„œ ì‹¤ì œ í´ë˜ìŠ¤ ì´ë¦„ì„ ê°€ì ¸ì˜´
                score: scores[i]
            });
        }
        
        return detections;
    }


    // ì‹¤ì‹œê°„ ë¹„ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ì— ë°”ìš´ë”© ë°•ìŠ¤ ê·¸ë¦¬ê¸° (ì´ì œ YOLOv8 ì‚¬ìš©)
    async function detectLiveObjects() {
        if (!yoloModel || video.paused || video.ended) {
            setTimeout(() => requestAnimationFrame(detectLiveObjects), 100); 
            return;
        }

        liveCtx.clearRect(0, 0, liveCanvas.width, liveCanvas.height); 
        try {
            // ë¹„ë””ì˜¤ í”„ë ˆì„ì„ í…ì„œë¡œ ë³€í™˜í•˜ê³  YOLOv8 ëª¨ë¸ ì…ë ¥ì— ë§ì¶° ì „ì²˜ë¦¬
            const tfImage = tf.browser.fromPixels(video);
            const resized = tf.image.resizeBilinear(tfImage, [MODEL_INPUT_SIZE, MODEL_INPUT_SIZE]);
            const normalized = resized.div(255.0); // 0-1 ìŠ¤ì¼€ì¼ë¡œ ì •ê·œí™”
            const expanded = normalized.expandDims(0); // ë°°ì¹˜ ì°¨ì› ì¶”ê°€

            // YOLOv8 ëª¨ë¸ ì¶”ë¡ 
            const predictions = await yoloModel.executeAsync(expanded);
            
            // í…ì„œ ë©”ëª¨ë¦¬ í•´ì œ
            tfImage.dispose();
            resized.dispose();
            normalized.dispose();
            expanded.dispose();

            // YOLOv8 ëª¨ë¸ ì¶œë ¥ í›„ì²˜ë¦¬
            // predictionsê°€ ë‹¨ì¼ í…ì„œì¼ ë•Œ (ex: [1, 25200, 85])
            const results = await processYoloOutput(predictions, video.videoWidth, video.videoHeight, customLabels, IOU_THRESHOLD, CONF_THRESHOLD);
            
            drawBoundingBoxes(liveCtx, liveCanvas, results);

        } catch (e) {
            console.error("ì‹¤ì‹œê°„ ê°ì§€ ì˜¤ë¥˜:", e);
        }
        
        setTimeout(() => requestAnimationFrame(detectLiveObjects), 100);
    }

    async function analyzeSnapshot(stage) {
        errorMessage.textContent = "";
        analysisStatusMessage.textContent = "ğŸ” ë¶„ì„ ì¤‘...";
        analyzeBeforeBtn.disabled = true;
        analyzeAfterBtn.disabled = true;

        if (!yoloModel) {
            errorMessage.textContent = "â— ëª¨ë¸ì´ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.";
            analysisStatusMessage.textContent = "";
            analyzeBeforeBtn.disabled = false;
            return;
        }

        try {
    // âœ… ë¹„ë””ì˜¤ í”„ë ˆì„ì´ ì¤€ë¹„ë˜ì—ˆëŠ”ì§€ í™•ì¸
    if (video.readyState < 2) {
        throw new Error("ë¹„ë””ì˜¤ í”„ë ˆì„ì´ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.");
    }

    // âœ… ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ë¹„ë””ì˜¤ í¬ê¸°ì™€ ë§ì¶¤
    modalCanvas.width = video.videoWidth;
    modalCanvas.height = video.videoHeight;

    // âœ… ë¹„ë””ì˜¤ í”„ë ˆì„ì„ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
    modalCtx.clearRect(0, 0, modalCanvas.width, modalCanvas.height);
    modalCtx.drawImage(video, 0, 0, modalCanvas.width, modalCanvas.height);

            // ìŠ¤ëƒ…ìƒ· ì´ë¯¸ì§€ë¥¼ í…ì„œë¡œ ë³€í™˜í•˜ê³  YOLOv8 ëª¨ë¸ ì…ë ¥ì— ë§ì¶° ì „ì²˜ë¦¬
            const tfImage = tf.browser.fromPixels(modalCanvas);
            const resized = tf.image.resizeBilinear(tfImage, [MODEL_INPUT_SIZE, MODEL_INPUT_SIZE]);
            const normalized = resized.div(255.0); // 0-1 ìŠ¤ì¼€ì¼ë¡œ ì •ê·œí™”
            const expanded = normalized.expandDims(0); // ë°°ì¹˜ ì°¨ì› ì¶”ê°€

            // YOLOv8 ëª¨ë¸ ì¶”ë¡ 
            const predictions = await yoloModel.executeAsync(expanded);
            
            // í…ì„œ ë©”ëª¨ë¦¬ í•´ì œ
            tfImage.dispose();
            resized.dispose();
            normalized.dispose();
            expanded.dispose();

            // YOLOv8 ëª¨ë¸ ì¶œë ¥ í›„ì²˜ë¦¬
            const results = await processYoloOutput(predictions, modalCanvas.width, modalCanvas.height, customLabels, IOU_THRESHOLD, CONF_THRESHOLD);
            
            const rawLabels = results.map(r => r.class); // YOLOv8ì´ ê°ì§€í•œ ì›ë³¸ ë ˆì´ë¸” (ì˜ˆ: "Book")
            // const friendlyLabels = rawLabels.map(mapLabelToFriendlyName); // mapLabelToFriendlyNameì´ ì´ì œ ì›ë³¸ ë ˆì´ë¸” ê·¸ëŒ€ë¡œ ë°˜í™˜í•˜ë¯€ë¡œ í•„ìš”ì—†ìŒ

            // ëª¨ë‹¬ ìº”ë²„ìŠ¤ì— ë°”ìš´ë”© ë°•ìŠ¤ ê·¸ë¦¬ê¸°
            drawBoundingBoxes(modalCtx, modalCanvas, results);

            const spaceGuess = guessSpace(rawLabels); // ì›ë³¸ ë ˆì´ë¸” ì „ë‹¬
            const tips = generateTips(rawLabels); // ì›ë³¸ ë ˆì´ë¸” ì „ë‹¬

            // 'ì–´ìˆ˜ì„ í•¨' ë¶„ì„ ë©”ì‹œì§€ (YOLOv8 ê°ì§€ ê²°ê³¼ ê¸°ë°˜)
            let aiMessage = "";
            // messyLabelsForScoringëŠ” ì´ë¯¸ ì†Œë¬¸ì ë°°ì—´ì´ë¯€ë¡œ, rawLabelsë„ ì†Œë¬¸ìë¡œ ë³€í™˜í•˜ì—¬ ë¹„êµ
            const messyObjectsDetected = rawLabels
            .filter(label => typeof label === 'string' && messyLabelsForScoring.includes(label.toLowerCase()))
            .length;
            const totalObjectsDetected = rawLabels.length;

            if (totalObjectsDetected === 0) {
                aiMessage = "ğŸ§¼ ì•„ì£¼ ê¹¨ë—í•œ ìƒíƒœì…ë‹ˆë‹¤.";
            } else if (messyObjectsDetected / totalObjectsDetected < 0.2) { // ê°ì§€ëœ ì–´ìˆ˜ì„ í•œ ë¬¼ê±´ ë¹„ìœ¨ì´ ë‚®ì„ ê²½ìš°
                aiMessage = "ğŸ§¹ ì •ëˆëœ ìƒíƒœì…ë‹ˆë‹¤.";
            } else {
                aiMessage = "â— ì–´ìˆ˜ì„ í•œ ìƒíƒœì…ë‹ˆë‹¤. ì •ë¦¬ê°€ í•„ìš”í•´ìš”.";
            }

            if (stage === 'before') {
                beforeLabels = rawLabels; // ì›ë³¸ ë ˆì´ë¸” ì €ì¥
                
                openResultModal(
                    "ğŸ“Œ ì •ë¦¬ ì „ ê³µê°„ ë¶„ì„ ê²°ê³¼",
                    spaceGuess,
                    tips,
                    '', // ì •ë¦¬ ì „ì—ëŠ” ì ìˆ˜ ì—†ìŒ
                    generateChecklistHtml(rawLabels), // ì›ë³¸ ë ˆì´ë¸” ì „ë‹¬
                    aiMessage 
                );
                analyzeAfterBtn.disabled = false; // ì •ë¦¬ í›„ ë²„íŠ¼ í™œì„±í™”
                analyzeBeforeBtn.disabled = false; // ë‹¤ì‹œ ë¶„ì„í•  ìˆ˜ ìˆë„ë¡ í™œì„±í™”
            } else { // stage === 'after'
                const { score, feedback } = calculateScore(beforeLabels, rawLabels); // ì›ë³¸ ë ˆì´ë¸” ì „ë‹¬
                
                openResultModal(
                    "âœ¨ ì •ë¦¬ í›„ ì ìˆ˜ ê²°ê³¼",
                    spaceGuess,
                    tips, 
                    score, 
                    generateChecklistHtml(rawLabels), // ì›ë³¸ ë ˆì´ë¸” ì „ë‹¬
                    `${feedback} ${aiMessage}`, 
                    true // 'ë‹¤ì‹œ ì‹œì‘' ë²„íŠ¼ í‘œì‹œ
                );
                analyzeBeforeBtn.disabled = true; // ì •ë¦¬ í›„ì—ëŠ” ë‹¤ì‹œ ì‹œì‘ ëˆ„ë¥´ê¸° ì „ê¹Œì§€ ì´ì „ ë²„íŠ¼ ë¹„í™œì„±í™”
            }
        } catch (e) {
            console.error("ë¶„ì„ ì˜¤ë¥˜:", e);
            errorMessage.textContent = "â— ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + e.message;
        } finally {
            analysisStatusMessage.textContent = "";
            if (stage === 'before') { 
                analyzeBeforeBtn.disabled = false;
                analyzeAfterBtn.disabled = false;
            } 
        }
    }

    // ì–´í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™”
    function resetApplication() {
        beforeLabels = [];
        beforeSnapshotData = null;
        analyzeAfterBtn.disabled = true;
        analyzeBeforeBtn.disabled = false;
        resultModalOverlay.style.display = 'none'; // ëª¨ë‹¬ ë‹«ê¸°
        errorMessage.textContent = "";
        analysisStatusMessage.textContent = "";
        liveCtx.clearRect(0, 0, liveCanvas.width, liveCanvas.height); // ì‹¤ì‹œê°„ ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
        
        if (!video.srcObject || !video.srcObject.active) {
            initCameraAndModel(); // ì¹´ë©”ë¼ ì¬ì‹œì‘
        }
        showScreen('cameraScreen'); // ì¹´ë©”ë¼ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ê¸°
    }

    // ì´ˆê¸° ì¹´ë©”ë¼ ë° ëª¨ë¸ ë¡œë“œ
    async function initCameraAndModel() {
        showScreen('loadingScreen');
        errorMessage.textContent = "";

        try {
            // 1. ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ ì‹œì‘
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: "environment", // í›„ë©´ ì¹´ë©”ë¼ ìš°ì„ 
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                } 
            });
            video.srcObject = stream;
            await new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    video.play();
                    resolve();
                };
            });
            liveCanvas.width = video.videoWidth;
            liveCanvas.height = video.videoHeight;
            modalCanvas.width = video.videoWidth;
            modalCanvas.height = video.videoHeight;
            console.log("âœ… Camera initialized.");

            // 2. ëª¨ë¸ ë° ë ˆì´ë¸” ë¡œë“œ
            analysisStatusMessage.textContent = "ëª¨ë¸ ë¡œë”© ì¤‘...";
            // yolov8n_oiv7_web_model/model.json ê²½ë¡œê°€ ë§ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.
            yoloModel = await tf.loadGraphModel('./models/yolov8n_oiv7_web_model/model.json'); 
            console.log("âœ… YOLOv8 Model loaded.");

            analysisStatusMessage.textContent = "ë ˆì´ë¸” ë¡œë”© ì¤‘...";
            customLabels = await loadLabels('./models/yolov8n_oiv7_web_model/label.txt'); // labels.txt ê²½ë¡œê°€ ë§ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.
            console.log("âœ… Custom Labels loaded:", customLabels.length, "labels.");

            // messyLabelsForScoring ì´ˆê¸°í™” (customLabelsì™€ hardcodedMessyLabelsì˜ êµì§‘í•©)
            messyLabelsForScoring = customLabels.filter(label => 
                hardcodedMessyLabels.includes(label) 
            ).map(label => label.toLowerCase()); // ì ìˆ˜ ê³„ì‚° ì‹œì—ëŠ” ì†Œë¬¸ìë¡œ ë¹„êµí•˜ê¸° ìœ„í•´ ë³€í™˜

            if (customLabels.length === 0) {
                errorMessage.textContent = "â— ëª¨ë¸ ë ˆì´ë¸”ì„ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. 'label.txt' íŒŒì¼ì„ í™•ì¸í•´ì£¼ì„¸ìš”.";
                return;
            }

            analysisStatusMessage.textContent = "";
            showScreen('cameraScreen');
            detectLiveObjects(); // ì‹¤ì‹œê°„ ê°ì§€ ì‹œì‘

        } catch (error) {
            console.error("Initialization error:", error);
            errorMessage.textContent = "â— ì•± ì´ˆê¸°í™” ì˜¤ë¥˜: " + error.message + " (ì¹´ë©”ë¼ ê¶Œí•œ, ëª¨ë¸ íŒŒì¼ ê²½ë¡œ ë“±ì„ í™•ì¸í•˜ì„¸ìš”)";
            showScreen('cameraScreen'); // ì˜¤ë¥˜ ì‹œì—ë„ ì¹´ë©”ë¼ í™”ë©´ìœ¼ë¡œ ì „í™˜í•˜ì—¬ ì‚¬ìš©ìì—ê²Œ ë©”ì‹œì§€ ë³´ì—¬ì¤Œ
            analyzeBeforeBtn.disabled = true; // ì˜¤ë¥˜ ë°œìƒ ì‹œ ë²„íŠ¼ ë¹„í™œì„±í™”
            analyzeAfterBtn.disabled = true;
        }
    }

    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    analyzeBeforeBtn.addEventListener("click", () => analyzeSnapshot('before'));
    analyzeAfterBtn.addEventListener("click", () => analyzeSnapshot('after'));

    // ì•± ì‹œì‘
    initCameraAndModel();
</script>
</body>
</html>